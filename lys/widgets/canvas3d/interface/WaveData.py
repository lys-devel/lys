import warnings
from lys.Qt import QtCore
from lys.errors import NotImplementedWarning

from .CanvasBase import CanvasPart3D, saveCanvas


class WaveData3D(CanvasPart3D):
    """
    Interface to access wave data in the canvas.
    """
    modified = QtCore.pyqtSignal()
    """This pyqtSignal is emimtted when the data is changed."""

    def __init__(self, canvas, wave):
        super().__init__(canvas)
        self._wave = wave
        self._wave.modified.connect(self._update)
        self._appearance = {}
        self._filter = None
        self._filteredWave = wave

    @saveCanvas
    def _update(self, *args, **kwargs):
        self._filteredWave = self._calcFilteredWave(self._wave, self._filter)
        self._updateData()
        self.modified.emit()

    def _calcFilteredWave(self, w, filter):
        if filter is not None:
            w = filter.execute(w)
        return w

    def getWave(self):
        """
        Get the wave.

        Return:
            Wave: The wave.
        """
        return self._wave

    def getFilteredWave(self):
        """
        Get the wave to which offset and filter have been applied.

        Return:
            Wave: The filtered wave.
        """
        return self._filteredWave

    def getName(self):
        """
        Get the name of the wave data.

        Return:
            str: The name.
        """
        return self._appearance.get('DataName', self.getWave().name)

    def setName(self, name):
        """
        Set the name of the data.

        Args:
            name(str): The name of the data.
        """
        self._appearance['DataName'] = name

    @saveCanvas
    def setVisible(self, visible):
        """
        Set the visibility of the data.

        Args:
            visible(bool): The visibility of the data.
        """
        self._setVisible(visible)
        self._appearance['Visible'] = visible

    def getVisible(self):
        """
        Get the visibility of the data.

        Return:
            bool: The visibility of the data.
        """
        return self._appearance.get('Visible', True)

    @saveCanvas
    def setFilter(self, filter=None):
        """
        Apply filter to the data.

        Args:
            filter(filter): The filter. See :class:`lys.filters.filter.FilterInterface.FilterInterface`
        """
        self._filter = filter
        self._update()

    def getFilter(self):
        """
        Get filter applied to the data.

        Returns:
            filter: The filter. See :class:`lys.filters.filter.FilterInterface.FilterInterface`

        """
        return self._filter

    def saveAppearance(self):
        """
        Save appearance from dictionary.

        Users can save/load appearance of data by save/loadAppearance methods.

        Return:
            dict: dictionary that include all appearance information.
        """
        return dict(self._appearance)

    @saveCanvas
    def loadAppearance(self, appearance):
        """
        Load appearance from dictionary.

        Users can save/load appearance of data by save/loadAppearance methods.

        Args:
            appearance(dict): dictionary that include all appearance information, which is usually generated by :meth:`saveAppearance` method.
        """
        self.setVisible(appearance.get('Visible', True))
        self.setName(appearance.get('DataName', self.getWave().name))
        self._loadAppearance(appearance)

    def _setVisible(self, visible):
        warnings.warn(str(type(self)) + " does not implement _setVisible(visible) method.", NotImplementedWarning)

    def _updateData(self):
        raise NotImplementedError(str(type(self)) + " does not implement _updateData() method.")

    def _loadAppearance(self, appearance):
        raise NotImplementedError(str(type(self)) + " does not implement _loadAppearance(appearance) method.")


class MeshData3D(WaveData3D):
    @saveCanvas
    def setColor(self, color=None, type="scalars"):
        """
        Set the color of the mesh data.

        If type == "scalars", the surface of the mesh is drawn using scalar data.
        In this case, *color* should be a name of colormap to be used.

        If type == "color", the surface of the mesh is colored by a single color.
        In this case, *color* should be a color string, length 3 RGB sequence.

        Args:
            color: See above.
            type: See above.
        """
        self.__setAppearance("colorType", type)
        self.__setAppearance("color", color)
        self._setColor(color, type)

    def getColor(self):
        """
        Get the color or colormap of the mesh. See :meth:`setColor`.
        
        Returns:
            colorlike or colormap: The color or colormap
        """
        return self.__getAppearance("color", "viridis")

    def getColorType(self):
        """
        Get the present color type of the mesh. See :meth:`setColor`.

        Returns:
            str: 'scalars' or 'color'
        """
        return self.__getAppearance("colorType", "scalars")

    @saveCanvas
    def showEdges(self, b):
        """
        Show edges of the object.

        Args:
            b(bool): Whether the edges of the object are shown.
        """
        self.__setAppearance("showEdges", b)
        self._showEdges(b)

    def edgesVisible(self):
        """
        Return if the edges are visible.

        Returns:
            bool: The visibility
        """
        return self.__getAppearance("showEdges", True)

    @saveCanvas
    def showMeshes(self, b):
        """
        Show edges of the mesh.

        Args:
            b(bool): Whether the edges of the mesh are shown.
        """
        self.__setAppearance("showMeshes", b)
        self._showMeshes(b)

    def meshesVisible(self):
        """
        Return if the meshes are visible.

        Returns:
            bool: The visibility
        """
        return self.__getAppearance("showMeshes", False)

    def __setAppearance(self, key, value):
        self._appearance[key] = value

    def __getAppearance(self, key, default=None):
        return self._appearance.get(key, default)

    def _loadAppearance(self, appearance):
        if "colorType" in appearance:
            self.setColor(appearance["color"], appearance["colorType"])
        if "showMeshes" in appearance:
            self.showMeshes(appearance["showMeshes"])
        if "showEdges" in appearance:
            self.showEdges(appearance["showEdges"])

    def _setColor(self, color, type):
        warnings.warn(str(type(self)) + " does not implement _setColor(color, type) method.", NotImplementedWarning)

    def _showEdges(self, b):
        warnings.warn(str(type(self)) + " does not implement _showEdges(b) method.", NotImplementedWarning)

    def _showMeshes(self, b):
        warnings.warn(str(type(self)) + " does not implement _showMeshes(b) method.", NotImplementedWarning)


